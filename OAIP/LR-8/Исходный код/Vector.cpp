#include "Vector.h"
#include "iostream"
#include "Print.h"
#include "Book.h"


/**
 * Конструктор без параметров
 */
Vector::Vector() {
    beg = nullptr;
    size = 0;
    cur = 0;
}

/**
 * Конструктор с параметрами
 * @param m
 */
Vector::Vector(int m) {
    beg = new Objecto *[m];
    cur = 0;
    size = m;
}

/**
 * Деструктор
 */
Vector::~Vector() {
    if (beg != nullptr)delete[] beg;
    beg = nullptr;
}

/**
 * Метод создания группы по переданному размеру.
 * @param event
 */
void Vector::MakeGroup(TEvent &event) {
    size = event.a;     //размер группы
    if (size < 1) {
        cout << "\nНельзя создать группы размером меньше 1!" << endl;
        return;
    }
    beg = new Objecto *[size];      //выделяем память под массив указателей cur=0; - текущая позиция
    cout << "\nГруппа содана (размер = " << size << ")!\n" << endl;
}

/**
 * Метод добавления существующего объекта иерархии в вектор
 * @param p
 */
void Vector::Add(Objecto *p) {
    if (cur < size) {
        beg[cur] = p;//добавление в вектор
        cur++;
    } else {
        cout << "Нельзя добавить объект, т.к. группа уже переполнена (размер группы = " << size << ")!\nМожете создать новую!\n";
    }
}

/**
 * Метод создания и добавления нового элемента в вектор.
 * Позволяет выбрать, какой из классов и иерархии инстанциировать.
 */
void Vector::Add() {
    if (cur >= size) {
        cout << "Нельзя добавить объект, т.к. группа уже переполнена (размер группы = " << size << ")!\nМожете создать новую!\n";
    }

    Objecto *p;
    //выбор из объектов двух возможных классов

    int y = getInt("1.Печатное издание\n2.Книга", 1, 2);
    if (y == 1)     //добавление объекта класса Print
    {
        Print *a = new (Print);
        a->Input();//ввод значений атрибутов
        p = a;
        Add(p);
    } else if (y == 2) //добавление объекта класса Book
    {
        Book *b = new Book;
        b->Input();   //ввод значений атрибутов
        p = b;
        Add(p);
    }
}

/**
 * Метод удаления текущего элемента из вектора,
 * на номер позиции которой указывает поле cur
 */
void Vector::Del() {
    if (cur < 1) {
        cout << "Группа итак пустая!" << endl;
        return;
    }
    cur--;
}

/**
 * Метод вывода в консоль элементов вектора
 */
void Vector::Show() {
    if (cur == 0) cout << "Список пуст!" << endl;
    Objecto **p = beg;  //указатель на указатель типа Objecto
    for (int i = 0; i < cur; i++) {
        if (i > 0) cout << endl;
        cout << (i + 1) << ":" << endl;
        (*p)->Show();   //вызов метода Show() (позднее связывание)
        p++;    //передвигаем указатель на следующий объект
    }
}

/**
 * Метод вывода в консоль элемента с номером k
 * @param k
 */
void Vector::ShowK(int k) {
    if (k == -100) {
        cout << "Номер элемента группы не задан!\n";
        return;
    }
    if (cur == 0) {
        cout << "Список пуст!" << endl;
        return;
    }
    if (k < 1 || k > cur) {
        cout << "Элемента с таким номером нет в массиве! Допустимые значения от 1 до " << cur << endl;
        return;
    }
    Objecto *p = beg[k-1];  //указатель на указатель типа Objecto
    (*p).ShowTitle();
}

/**
 * Метод просмотра названий всех элементов группы
 * @param a
 */
void Vector::ShowT(TEvent &event) {
    HandleEvent(event);   //Передаеется событие на обработку обработку объектам группы
}

/**
 * Метод получения текущей позиции в векторе
 * @return
 */
int Vector::operator()() {
    return cur;
}

/**
 * Метод обработки событий.
 * Принимает объект события в качестве параметра
 * и если событие находится в активно/не обработанном состоянии (событие-сообщени)
 * то передает событие на обработку каждому объекту по очереди.
 * Таким образом событие найдет своего адресата.
 * @param e
 */
void Vector::HandleEvent(const TEvent &e) {
    if (e.what == evMessage) {
        Objecto **p = beg;
        for (int i = 0; i < cur; i++) {
            (*p)->HandleEvent(e); //вызов метода (позднее связывание)
            p++;
        }
    }
}
